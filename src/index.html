<!DOCTYPE html>
<html>
<head>
	<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
	<meta content="utf-8" http-equiv="encoding">
	
	<title>Typoglyph</title>
	<link rel="icon" type="image/ico" href="images/favicon.ico">
	
	<link rel="stylesheet" type="text/css" href="styles/common.css">
	<link rel="stylesheet" type="text/css" href="styles/index.css">
	
	<script type="text/javascript" src="scripts/util.js"></script>
	<script type="text/javascript" src="scripts/puzzle.js"></script>
	<script type="text/javascript" src="scripts/anim.js"></script>
	<script type="text/javascript" src="scripts/statistics.js"></script>
	<script>
	
	
	// Imports
	var util	= typoglyph.util;
	var Gap		= typoglyph.puzzle.Gap;
	var Option	= typoglyph.puzzle.Option;
	var Puzzle	= typoglyph.puzzle.Puzzle;
	var Animation			= typoglyph.anim.Animation;
	var StatisticsTracker	= typoglyph.StatisticsTracker;
	
	
	// Global variables
	var puzzleSet = null;
	var currentPuzzleIndex = null;
	var statistics = new StatisticsTracker();
	var completionGraphic = null;
	
	
	// Event handlers
	/**
	 * Called when the browser has finished (re)loading the document
	 */
	function onLoad() {
		console.log("onLoad");
		completionGraphic = new Animation(document.getElementById("completion_graphic"), 1000);
		
		puzzleSet = createTestPuzzles(3);
		currentPuzzleIndex = 0;
		renderCurrentPuzzle();
		renderStatistics();
	}
	
	/**
	 * @param {MouseEvent} event Information about the click event
	 * @param {HTMLElement} element The DOM element representing the button which was clicked
	 */
	function onNextPuzzleButtonClicked(event, element) {
		console.log("onNextPuzzleButtonClicked: event=" + event + ", element=" + element);
		
		var puzzle = puzzleSet[currentPuzzleIndex];
		var stats = statistics;
		var isAnsweredCorrectly = isPuzzleFilledCorrectly(puzzle);
		
		stats.onPuzzleAnswered(puzzle, isAnsweredCorrectly);
		currentPuzzleIndex++;
		
		// Cancel any currently visible graphic
		completionGraphic.cancel();
		completionGraphic.onPreStart = function(e) {
			console.log("completionGraphic.onPreStart: e=" + e);
			
			fetchCompletionGraphics(isAnsweredCorrectly, false, function(graphics) {
				e.src = util.randomElement(graphics);
			});
			util.setImageRotation(e, util.randomInt(-50, 50));
			
			// Get the size *after* we set the image and rotation as it may change
			var ew = util.getElementWidth(e);
			var eh = util.getElementHeight(e);
			
			// Position the center of the image where the mouse was clicked, or as close as
			// possible if the click was near the edge of the viewport
			e.style.left = Math.min(util.getViewportWidth() - ew, Math.max(0, event.pageX - 0.5 * ew)) + "px";
			e.style.top = Math.min(util.getViewportHeight() - eh, Math.max(0, event.pageY - 0.5 * eh)) + "px";
		}
		completionGraphic.onPostStop = function(e) {
			console.log("completionGraphic.onPostStop e=" + e);
		}
		
		// Show the completion graphic
		completionGraphic.start();
		
		// Move on to the next puzzle
		if (currentPuzzleIndex < puzzleSet.length) {
			// Not all puzzles have yet been completed
			renderStatistics();
			renderCurrentPuzzle();
		} else {
			// All puzzles have been completed
			// Load the results page
			var correct = stats.getCorrectlyAnsweredPuzzlesCount();
			var total = stats.getAnsweredPuzzlesCount();
			window.location.href = "results.html?correct=" + correct + "&total=" + total;
		}
	}
	
	/**
	 * @param {DragEvent} event Information about the drag event
	 * @param {HTMLElement} element The DOM element representing the option which was dragged
	 * @param {int} optionId The ID of the option which was dragged, in the context of the
	 *     currently shown puzzle
	 */
	function onStartDraggingOption(event, element, optionId) {
		console.log("onStartDraggingOption: event=" + event + ", element=" + element + ", optionId=" + optionId);
		event.dataTransfer.setData("optionId", optionId);
	}
	
	/**
	 * @param {DragEvent} event Information about the drag event
	 * @param {HTMLElement} element The DOM element representing the gap you're dragging something
	 *     over
	 * @param {int} gapId The ID of the gap which is being gragged over, in the context of the
	 *     currently shown puzzle
	 */
	function onDragOverGap(event, element, gapId) {
		var optionId = event.dataTransfer.getData("optionId");
		console.log("onDragOverGap: event=" + event + ", element=" + element + ", optionId=" + optionId + ", gapId=" + gapId);
		
		if (optionId !== null) {
			optionId = parseInt(optionId);
			
			// The element being dragged is an option
			// Prevent the default behaviour to allow it to be dropped here
			event.preventDefault();
		}
	}
	
	/**
	 * @param {DragEvent} event Information about the drag event
	 * @param {HTMLElement} element The DOM element representing the gap you dropped something onto
	 * @param {int} gapId The ID of the gap which is being dropped onto, in the context of the
	 *     currently shown puzzle
	 */
	function onDropOntoGap(event, element, gapId) {
		var optionId = event.dataTransfer.getData("optionId");
		console.log("onDropOntoGap: event=" + event + ", element=" + element + ", optionId=" + optionId + ", gapId=" + gapId);
		
		if (optionId !== null) {
			optionId = parseInt(optionId, 10);
			
			// The element being dragged is an option
			// Prevent the default behaviour to allow it to be dropped here
			event.preventDefault();
			
			var puzzle = puzzleSet[currentPuzzleIndex];
			var option = puzzle.getOptionById(optionId);
			var gap = puzzle.getGapById(gapId);
			gap.setCurrentChoice(option);
			renderCurrentPuzzle();
		}
	}
	
	
	// Rendering functions
	/**
	 * 
	 */
	function renderStatistics() {
		var stats = statistics;
		var latestAnswer = stats.wasLatestAnswerCorrect();
		document.getElementById("answer").innerHTML = (latestAnswer == null) ? "N/A" : (latestAnswer ? "Correct" : "Incorrect");
		document.getElementById("correctAnswers").innerHTML = stats.getCorrectlyAnsweredPuzzlesCount();
		document.getElementById("totalAnswers").innerHTML = stats.getAnsweredPuzzlesCount();
		
		document.getElementById("puzzleNumber").innerHTML = (currentPuzzleIndex + 1);
		document.getElementById("totalPuzzles").innerHTML = puzzleSet.length;
	}
	
	/**
	 * 
	 */
	function renderCurrentPuzzle() {
		var puzzle = puzzleSet[currentPuzzleIndex];
		document.getElementById("sentence").innerHTML = renderPuzzleHtml(puzzle);
		document.getElementById("options").innerHTML = renderPuzzleOptionsHtml(puzzle);
	}
	
	/**
	 * @param {Puzzle} puzzle
	 * @return {String}
	 */
	function renderPuzzleHtml(puzzle) {
		var html = "";
		var sentence = puzzle.getSentence();
		var gaps = puzzle.getGaps();
		for (var i = 0; i < sentence.length + 1; i++) {
			// see if there is a gap which is supposed to go in this position
			var gap = puzzle.getGapAtPosition(i);
			if (gap !== null) {
				html += renderPuzzleGapHtml(gap);
			}
			
			html += sentence.charAt(i);
		}
		return html;
	}
	
	/**
	 * @param {Gap} gap
	 * @return {String}
	 */
	function renderPuzzleGapHtml(gap) {
		var html = "";
		var ondrop = "onDropOntoGap(event, this, " + gap.getId() + ");";
		var ondragover = "onDragOverGap(event, this, " + gap.getId() + ");";
		html += "<span class='blankSpace' ondrop='" + ondrop + "' ondragover='" + ondragover + "'>";
		
		var option = gap.getCurrentChoice();
		if (option !== null)
			html += renderPuzzleOptionHtml(option);
		
		html += "</span>";
		return html;
	}
	
	/**
	 * @param {Puzzle} puzzle
	 * @return {String}
	 */
	function renderPuzzleOptionsHtml(puzzle) {
		var html = "";
		var options = puzzle.getOptions();
		for (var i = 0; i < options.length; i++) {
			var option = options[i];
			html += renderPuzzleOptionHtml(option);
		}
		return html;
	}
	
	/**
	 * @param {Option} option
	 * @return {String}
	 */
	function renderPuzzleOptionHtml(option) {
		var html = "";
		var ondragstart = "onStartDraggingOption(event, this, " + option.getId() + ");";
		html += "<span class='draggableOption' draggable='true' ondragstart='" + ondragstart + "'>";
		html += option.getValue();
		html += "</span>";
		return html;
	}
	
	
	/**
	 * @param {Puzzle} puzzle
	 * @return {boolean}
	 */
	function isPuzzleFilledCorrectly(puzzle) {
		return puzzle.areAllGapsFilledCorrectly();
	}
	
	
	// Functions which call the backend
	/**
	 * @param {boolean} correct True if you want to fetch graphics representing a correct answer or
	 *     false if you want to fetch graphics representing an incorrect answer
	 * @param {boolean} async True if you want the graphics to be fetched asynchronously
	 * @param {function(Array<String>)} callback The function to call when the graphics have been
	 *     fetched
	 * @return {Array<String>}
	 */
	function fetchCompletionGraphics(correct, async, callback) {
		var req = new XMLHttpRequest();
		req.onreadystatechange = function() {
			if (req.readyState === 4 && req.status === 200) {
				var resp = req.responseText;
				var paths = JSON.parse(resp);
				callback(paths);
			}
		}
		req.open("GET", "backend/getCompletionGraphics.php?correct_answer=" + (correct ? "true" : "false"), async);
		req.send();
	}
	
	/**
	 * This function generates puzzles straight from the browser, without needing to call the
	 * backend. Once the backend has been updated to use the new puzzle data structure, this
	 * function will be removed and any code calling it will need to be updated to use the updated
	 * backend functionallity.
	 * 
	 * @param {int} count How many test puzzles to create. Note that a maximum of 3 puzzles will be
	 *     returned.
	 * @return {Array<Puzzle>}
	 */
	function createTestPuzzles(count) {
		var sentences = [
			"Hello world",
			"This is a test sentence Can you work out which punctuation to use",
			"Hello my name is Jake How are you today" ];
		var options = [
			new Option("."), new Option(","), new Option(";"), new Option("#"), new Option("!"), new Option("?") ];
		
		var gaps = [
			[ new Gap(11, new Option("!")) ],
			[ new Gap(23, new Option(".")), new Gap(65, new Option("?")) ],
			[ new Gap(5, new Option(",")), new Gap(21, new Option(".")), new Gap(39, new Option("?")) ] ];
		
		var puzzles = [];
		for (var i = 0; i < Math.min(sentences.length, count); i++) {
			var puzzle = new Puzzle(sentences[i], options, gaps[i]);
			fillMissingGaps(puzzle);
			puzzles.push(puzzle);
		}
		
		for (var i = 0; i < puzzles.length; i++) {
			console.log("    " + puzzles[i]);
		}
		return puzzles;
	}
	
	/**
	 * Adds a gap with a null solution just before every space in the sentence, assuming no gap has
	 * already been added in that position.
	 * 
	 * @param {Puzzle} puzzle
	 */
	function fillMissingGaps(puzzle) {
		var sentence = puzzle.getSentence();
		for (var i = 0; i <= sentence.length; i++) {
			if (sentence.charAt(i) === ' ' || i === sentence.length) {
				if (puzzle.getGapAtPosition(i) === null) {
					// Puzzle doesn't yet have a gap in this position
					puzzle.getGaps().push(new Gap(i, null));
				}
			}
		}
	}
	
	
	// Utility functions
	/**
	 * @param {HTMLElement} e
	 * @param {String} className
	 * @return {boolean}
	 */
	function isElementOfClass(e, className) {
		var regExp = new RegExp("(^| )" + className + "($| )");
		return e.className.match(regExp);
	}
	
	/**
	 * @param {HTMLElement} e
	 * @param {String} className
	 */
	function removeClassFromElement(e, className) {
		var regExp = new RegExp("(^| )" + className + "($| )");
		e.className = e.className.replace(regExp, "");
	}
	</script>
</head>
<body onload="onLoad();">
	<!-- starts hidden, but will be shown briefly after user finishes each puzzle -->
	<image id="completion_graphic" style="visibility: hidden;"/>
	
	<table>
		<tr>
			<td>Previous puzzle:</td>
			<td><span id="answer"/></td>
		</td>
		<tr>
			<td>Score:</td>
			<td><span id="correctAnswers"></span> / <span id="totalAnswers"></span></td>
		</tr>
		<tr>
			<td>Puzzle:</td>
			<td><span id="puzzleNumber"></span> / <span id="totalPuzzles"></span></td>
		</tr>
		<tr>
			<td>Options:</td>
			<td><span id="options"/></td>
		</tr>
		<tr>
			<td>Sentence:</td>
			<td><span id="sentence"/></td>
		</tr>
		<tr>
			<td><button id="nextPuzzle" class="button" onclick="onNextPuzzleButtonClicked(event, this);">Check answer | Next puzzle</button></td>
		</tr>
		<tr>
			<td><a href="rawData.html">View raw data</a></td>
			<td><a href="info.php">View PHP info</a></td>
		</tr>
	</table>
</body>
</html>
