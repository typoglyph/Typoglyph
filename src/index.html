<!DOCTYPE html>
<html>
<head>
	<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
	<meta content="utf-8" http-equiv="encoding">
	
	<title>Typoglyph</title>
	<link rel="icon" type="image/ico" href="images/favicon.ico">
	
	<link rel="stylesheet" type="text/css" href="styles/common.css">
	<link rel="stylesheet" type="text/css" href="styles/index.css">
	
	<!-- see https://github.com/davidjbradshaw/iframe-resizer -->
	<script type="text/javascript" src="scripts/lib/iframe-resizer-v3.5.0/iframeResizer.min.js"></script>
	<script type="text/javascript" src="scripts/common.js"></script>
	<script type="text/javascript" src="scripts/util.js"></script>
	<script type="text/javascript" src="scripts/puzzle.js"></script>
	<script type="text/javascript" src="scripts/statistics.js"></script>
	<script type="text/javascript" src="scripts/ui.js"></script>
	<script>
	
	
	// Imports
	var util = typoglyph.util;
	var Puzzle = typoglyph.puzzle.Puzzle;
	var StatisticsTracker = typoglyph.StatisticsTracker;
	var ProgressBarDrawer = typoglyph.ui.ProgressBarDrawer;
	var CompletionGraphicDrawer = typoglyph.ui.CompletionGraphicDrawer;
	
	// Constants
	var PUZZLE_SET_SIZE = 5;
	
	
	// Global variables
	var _puzzleSet = null;
	var _currentPuzzleIndex = null;
	var _statistics = StatisticsTracker.create();
	var _progressBarDrawer = null;
	var _completionGraphicDrawer = null;
	
	
	// Event handlers
	/**
	 * Called when the browser has finished (re)loading the document
	 */
	function onLoad() {
		console.log("onLoad");
		
		// see https://github.com/davidjbradshaw/iframe-resizer
		iFrameResize({
			log: false,
			checkOrigin: [ "http://localhost:8080", "https://localhost:8080" ],
			
			closedCallback: function(iframeId) {
				console.debug("iFrameResize.closedCallback: iframeId=" + iframeId);
			},
			initCallback: function(iframe) {
				console.debug("iFrameResize.initCallback: iframe=" + iframe);
			},
			messageCallback: function(iframe, message) {
				console.debug("iFrameResize.messageCallback: iframe=" + iframe + ", msg=" + message);
			},
			resizedCallback: function(iframe, height, width, type) {
				console.debug("iFrameResize.resizedCallback: iframe=" + iframe + ", w=" + width + ", h=" + height + ", type=" + type);
			}
		});
		
		var correctCompletionGraphics = null;
		var incorrectCompletionGraphics = null;
		// execute synchronously to avoid race condition
		fetchCompletionGraphics(true, false, function(graphics) { correctCompletionGraphics = graphics; });
		fetchCompletionGraphics(false, false, function(graphics) { incorrectCompletionGraphics = graphics; });
		
		_progressBarDrawer = ProgressBarDrawer.create(PUZZLE_SET_SIZE);
		_completionGraphicDrawer = CompletionGraphicDrawer.create(correctCompletionGraphics, incorrectCompletionGraphics, 1000);
		startNewPuzzleSet();
	}
	
	function startNewPuzzleSet() {
		/**
		 * @param {Array<Puzzle>} puzzles
		 */
		function onPuzzlesLoaded(puzzles) {
			console.log("startNewPuzzleSet.onPuzzlesLoaded: " + puzzles);
			_puzzleSet = puzzles;
			_currentPuzzleIndex = 0;
			_statistics.reset();
			renderCurrentPuzzle();
			renderStatistics();
		}
		fetchPuzzlesFromBackend(PUZZLE_SET_SIZE, true, onPuzzlesLoaded);
	}
	
	/**
	 * @param {MouseEvent} event Information about the event which completed the puzzle
	 * @param {Puzzle} puzzle
	 * @param {boolean} correct
	 */
	function onPuzzleComplete(event, puzzle, correct) {
		console.log("onPuzzleComplete: event=" + event + ", puzzle=" + puzzle + ", correct=" + correct);
		
		_statistics.onPuzzleAnswered(puzzle, correct);
		_currentPuzzleIndex++;
		
		renderPuzzleResult();
		setTimeout(
			function() {
				// Move on to the next puzzle
				if (_currentPuzzleIndex < _puzzleSet.length) {
					// Not all puzzles have yet been completed
					renderStatistics();
					renderCurrentPuzzle();
				} else {
					// All puzzles have been completed
					// Load the results page
					renderPuzzleSetResults();
				}
			},
			2000);
	}
	
	
	// Rendering functions
	/**
	 * 
	 */
	function renderStatistics() {
		var progressBarHolder = document.getElementById("progressBarHolder");
		var drawnProgressBar = _progressBarDrawer.draw(_statistics);
		util.removeAllChildren(progressBarHolder);
		progressBarHolder.appendChild(drawnProgressBar);
	}
	
	/**
	 * 
	 */
	function renderCurrentPuzzle() {
		var frame = document.getElementById("main");
		util.addOneOffEventListener(frame, "load", function(event) {
			var currentPuzzle = _puzzleSet[_currentPuzzleIndex];
			event.target.contentWindow.setOnPuzzleCompleteListener(onPuzzleComplete);
			event.target.contentWindow.showPuzzle(currentPuzzle);
		});
		frame.src = "puzzle.html";
	}
	
	/**
	 * 
	 */
	function renderPuzzleResult() {
		var completionGraphicHolder = document.getElementById("completionGraphicHolder");
		var completionGraphic = _completionGraphicDrawer.draw(_statistics.getLatestStatistic().result);
		completionGraphicHolder.appendChild(completionGraphic);
		setTimeout(function() { util.removeAllChildren(completionGraphicHolder); }, 1000);
		
		var frame = document.getElementById("main");
		util.addOneOffEventListener(frame, "load", function(event) {
			event.target.contentWindow.showResults(_statistics);
		});
		frame.src = "completion.html";
	}
	
	/**
	 * 
	 */
	function renderPuzzleSetResults() {
		var frame = document.getElementById("main");
		util.addOneOffEventListener(frame, "load", function(event) {
			event.target.contentWindow.setOnNextPuzzleSetListener(function(event) {
				startNewPuzzleSet();
			});
			event.target.contentWindow.showResults(_statistics);
		});
		frame.src = "results.html";
	}
	
	
	// Functions which call the backend	
	/**
	 * Fetches the specified number of puzzles from the backend, and then passes them to a
	 * specified callback function. Puzzles can be fetched asynchronously if required.
	 * 
	 * @param {int} count How many puzzles to fetch. Note that the number of fetched puzzles could
	 *     be smaller if there aren't that many unique puzzles available.
	 * @param {boolean} async True if you want the puzzles should be fetched asynchronously. Note:
	 *     Specifying false means this function will not return until after the specified callback
	 *     function has been called and has returned.
	 * @param {function(Array<Puzzle>)} The function which will be called when the puzzles have
	 *     finished being loaded.
	 */
	function fetchPuzzlesFromBackend(count, async, callback) {
		var req = new XMLHttpRequest();
		req.onreadystatechange = function() {
			if (req.readyState === 4 && req.status === 200) {
				var resp = req.responseText;
				var puzzles = Puzzle.fromJsonArray(resp);
				callback(puzzles);
			}
		};
		req.open("GET", "backend/getRandomPuzzles.php?count=" + count, async);
		req.send();
	}
	
	/**
	 * @param {boolean} correct True if you want to fetch graphics representing a correct answer or
	 *     false if you want to fetch graphics representing an incorrect answer
	 * @param {boolean} async True if you want the graphics to be fetched asynchronously
	 * @param {function(Array<String>)} callback The function to call when the graphics have been
	 *     fetched
	 * @return {Array<String>}
	 */
	function fetchCompletionGraphics(correct, async, callback) {
		var req = new XMLHttpRequest();
		req.onreadystatechange = function() {
			if (req.readyState === 4 && req.status === 200) {
				var resp = req.responseText;
				var paths = JSON.parse(resp);
				callback(paths);
			}
		}
		req.open("GET", "backend/getCompletionGraphics.php?correct_answer=" + (correct ? "true" : "false"), async);
		req.send();
	}
	</script>
</head>
<body onload="onLoad();">
	<span id="completionGraphicHolder"></span>
	<span id="progressBarHolder"></span>
	<iframe id="main" frameborder="0" scrolling="no" seamless="seamless" style="width:100%;"></iframe>
</body>
</html>
