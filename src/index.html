<!DOCTYPE html>
<html>
<head>
	<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
	<meta content="utf-8" http-equiv="encoding">
	
	<title>Typoglyph</title>
	<link rel="icon" type="image/ico" href="images/favicon.ico">
	
	<link rel="stylesheet" type="text/css" href="styles/common.css">
	<link rel="stylesheet" type="text/css" href="styles/index.css">
	
	<script type="text/javascript" src="scripts/util.js"></script>
	<script type="text/javascript" src="scripts/puzzle.js"></script>
	<script type="text/javascript" src="scripts/anim.js"></script>
	<script type="text/javascript" src="scripts/statistics.js"></script>
	<script>
	
	
	// Imports
	var util = typoglyph.util;
	var Puzzle = typoglyph.puzzle.Puzzle;
	var Animation = typoglyph.anim.Animation;
	var StatisticsTracker = typoglyph.StatisticsTracker;
	
	
	// Global variables
	var _puzzleSet = null;
	var _currentPuzzleIndex = null;
	var _statistics = new StatisticsTracker();
	var _completionGraphic = null;
	
	
	// Event handlers
	/**
	 * Called when the browser has finished (re)loading the document
	 */
	function onLoad() {
		/**
		 * @param {Array<Puzzle>} puzzles
		 */
		function onPuzzlesLoaded(puzzles) {
			console.log("onLoad.onPuzzlesLoaded: " + puzzles);
			_puzzleSet = puzzles;
			_currentPuzzleIndex = 0;
			renderCurrentPuzzle();
			renderStatistics();
		}
		
		console.log("onLoad");
		fetchPuzzlesFromBackend(5, true, onPuzzlesLoaded);
		_completionGraphic = new Animation(document.getElementById("completionGraphic"), 1000);
	}
	
	/**
	 * @param {MouseEvent} event Information about the click event
	 * @param {HTMLElement} element The DOM element representing the button which was clicked
	 */
	function onNextPuzzleButtonClicked(event, element) {
		console.log("onNextPuzzleButtonClicked: event=" + event + ", element=" + element);
		
		var puzzle = _puzzleSet[_currentPuzzleIndex];
		var stats = _statistics;
		var completionGraphic = _completionGraphic;
		var isAnsweredCorrectly = isPuzzleFilledCorrectly(puzzle);
		
		stats.onPuzzleAnswered(puzzle, isAnsweredCorrectly);
		_currentPuzzleIndex++;
		
		// Cancel any currently visible graphic
		completionGraphic.cancel();
		completionGraphic.onPreStart = function(e) {
			console.log("completionGraphic.onPreStart: e=" + e);
			
			fetchCompletionGraphics(isAnsweredCorrectly, false, function(graphics) {
				e.src = util.randomElement(graphics);
			});
			util.setImageRotation(e, util.randomInt(-50, 50));
			
			// Get the size *after* we set the image and rotation as it may change
			var ew = util.getElementWidth(e);
			var eh = util.getElementHeight(e);
			
			// Position the center of the image where the mouse was clicked, or as close as
			// possible if the click was near the edge of the viewport
			e.style.left = Math.min(util.getViewportWidth() - ew, Math.max(0, event.pageX - 0.5 * ew)) + "px";
			e.style.top = Math.min(util.getViewportHeight() - eh, Math.max(0, event.pageY - 0.5 * eh)) + "px";
		}
		completionGraphic.onPostStop = function(e) {
			console.log("completionGraphic.onPostStop e=" + e);
		}
		
		// Show the completion graphic
		completionGraphic.start();
		
		// Move on to the next puzzle
		if (_currentPuzzleIndex < _puzzleSet.length) {
			// Not all puzzles have yet been completed
			renderStatistics();
			renderCurrentPuzzle();
		} else {
			// All puzzles have been completed
			// Load the results page
			var correct = stats.getCorrectlyAnsweredPuzzlesCount();
			var total = stats.getAnsweredPuzzlesCount();
			window.location.href = "results.html?correct=" + correct + "&total=" + total;
		}
	}
	
	/**
	 * @param {DragEvent} event Information about the drag event
	 * @param {HTMLElement} element The DOM element representing the option which was dragged
	 * @param {int} optionId The ID of the option which was dragged, in the context of the
	 *     currently shown puzzle
	 */
	function onStartDraggingOption(event, element, optionId) {
		console.log("onStartDraggingOption: event=" + event + ", element=" + element + ", optionId=" + optionId);
		event.dataTransfer.setData("optionId", optionId);
	}
	
	/**
	 * @param {DragEvent} event Information about the drag event
	 * @param {HTMLElement} element The DOM element representing the gap you're dragging something
	 *     over
	 * @param {int} gapId The ID of the gap which is being gragged over, in the context of the
	 *     currently shown puzzle
	 */
	function onDragOverGap(event, element, gapId) {
		var optionId = event.dataTransfer.getData("optionId");
		console.log("onDragOverGap: event=" + event + ", element=" + element + ", optionId=" + optionId + ", gapId=" + gapId);
		
		if (optionId !== null) {
			optionId = parseInt(optionId);
			
			// The element being dragged is an option
			// Prevent the default behaviour to allow it to be dropped here
			event.preventDefault();
		}
	}
	
	/**
	 * @param {DragEvent} event Information about the drag event
	 * @param {HTMLElement} element The DOM element representing the gap you dropped something onto
	 * @param {int} gapId The ID of the gap which is being dropped onto, in the context of the
	 *     currently shown puzzle
	 */
	function onDropOntoGap(event, element, gapId) {
		var optionId = event.dataTransfer.getData("optionId");
		console.log("onDropOntoGap: event=" + event + ", element=" + element + ", optionId=" + optionId + ", gapId=" + gapId);
		
		if (optionId !== null) {
			optionId = parseInt(optionId, 10);
			
			// The element being dragged is an option
			// Prevent the default behaviour to allow it to be dropped here
			event.preventDefault();
			
			var puzzle = _puzzleSet[_currentPuzzleIndex];
			var option = puzzle.getOptionById(optionId);
			var gap = puzzle.getGapById(gapId);
			gap.setCurrentChoice(option);
			renderCurrentPuzzle();
		}
	}
	
	
	// Rendering functions
	/**
	 * 
	 */
	function renderStatistics() {
		document.getElementById("progressBar").value = _currentPuzzleIndex;
		document.getElementById("progressBar").max = _puzzleSet.length;
	}
	
	/**
	 * 
	 */
	function renderCurrentPuzzle() {
		var puzzle = _puzzleSet[_currentPuzzleIndex];
		var sentenceElement = document.getElementById("puzzleSentence");
		var optionsElement = document.getElementById("puzzleOptions");
		util.removeAllChildren(sentenceElement);
		util.removeAllChildren(optionsElement);
		sentenceElement.appendChild(renderPuzzle(puzzle));
		optionsElement.appendChild(renderPuzzleOptions(puzzle));
	}
	
	/**
	 * @param {Puzzle} puzzle
	 * @return {HTMLElement}
	 */
	function renderPuzzle(puzzle) {
		var e = document.createElement("span");
		var sentence = puzzle.getSentence();
		var gaps = puzzle.getGaps();
		for (var i = 0; i < sentence.length + 1; i++) {
			// see if there is a gap which is supposed to go in this position
			var gap = puzzle.getGapAtPosition(i);
			if (gap !== null) {
				e.appendChild(renderPuzzleGap(gap));
			}
			e.appendChild(document.createTextNode(sentence.charAt(i)));
		}
		return e;
	}
	
	/**
	 * @param {Gap} gap
	 * @return {HTMLElement}
	 */
	function renderPuzzleGap(gap) {
		var id = gap.getId();
		var e = document.createElement("span");
		e.className = "blankSpace";
		e.addEventListener("drop", function(event) { onDropOntoGap(event, event.target, id); });
		e.ondragover = function(event) { onDragOverGap(event, event.target, id); };
		
		var option = gap.getCurrentChoice();
		if (option !== null)
			e.appendChild(renderPuzzleOption(option));
		
		return e;
	}
	
	/**
	 * @param {Puzzle} puzzle
	 * @return {HTMLElement}
	 */
	function renderPuzzleOptions(puzzle) {
		var e = document.createElement("span");
		var options = puzzle.getOptions();
		for (var i = 0; i < options.length; i++) {
			var option = renderPuzzleOption(options[i]);
			e.appendChild(option);
		}
		return e;
	}
	
	/**
	 * @param {Option} option
	 * @return {HTMLElement}
	 */
	function renderPuzzleOption(option) {
		var id = option.getId();
		var e = document.createElement("span");
		e.className = "draggableOption";
		e.draggable = true;
		e.innerHTML = option.getValue();
		e.addEventListener("dragstart", function(event) { console.log("dragstart"); onStartDraggingOption(event, event.target, id); });
		return e;
	}
	
	
	/**
	 * @param {Puzzle} puzzle
	 * @return {boolean}
	 */
	function isPuzzleFilledCorrectly(puzzle) {
		return puzzle.areAllGapsFilledCorrectly();
	}
	
	
	// Functions which call the backend	
	/**
	 * Fetches the specified number of puzzles from the backend, and then passes them to a
	 * specified callback function. Puzzles can be fetched asynchronously if required.
	 * 
	 * @param {int} count How many puzzles to fetch. Note that the number of fetched puzzles could
	 *     be smaller if there aren't that many unique puzzles available.
	 * @param {boolean} async True if you want the puzzles should be fetched asynchronously. Note:
	 *     Specifying false means this function will not return until after the specified callback
	 *     function has been called and has returned.
	 * @param {function(Array<Puzzle>)} The function which will be called when the puzzles have
	 *     finished being loaded.
	 */
	function fetchPuzzlesFromBackend(count, async, callback) {
		var req = new XMLHttpRequest();
		req.onreadystatechange = function() {
			if (req.readyState === 4 && req.status === 200) {
				var resp = req.responseText;
				var puzzles = Puzzle.fromJsonArray(resp);
				callback(puzzles);
			}
		};
		req.open("GET", "backend/getRandomPuzzles.php?count=" + count, async);
		req.send();
	}
	
	/**
	 * @param {boolean} correct True if you want to fetch graphics representing a correct answer or
	 *     false if you want to fetch graphics representing an incorrect answer
	 * @param {boolean} async True if you want the graphics to be fetched asynchronously
	 * @param {function(Array<String>)} callback The function to call when the graphics have been
	 *     fetched
	 * @return {Array<String>}
	 */
	function fetchCompletionGraphics(correct, async, callback) {
		var req = new XMLHttpRequest();
		req.onreadystatechange = function() {
			if (req.readyState === 4 && req.status === 200) {
				var resp = req.responseText;
				var paths = JSON.parse(resp);
				callback(paths);
			}
		}
		req.open("GET", "backend/getCompletionGraphics.php?correct_answer=" + (correct ? "true" : "false"), async);
		req.send();
	}
	</script>
</head>
<body onload="onLoad();">
	<!-- starts hidden, but will be shown briefly after user finishes each puzzle -->
	<image id="completionGraphic" style="visibility: hidden;"/>
	<progress id="progressBar" value="0"></progress>
	
	<table>
		<tr>
			<td>Options:</td>
			<td id="puzzleOptions"></td>
		</tr>
		<tr>
			<td>Sentence:</td>
			<td id="puzzleSentence"></td>
		</tr>
		<tr>
			<td><button id="nextPuzzle" class="button" onclick="onNextPuzzleButtonClicked(event, this);">Check answer | Next puzzle</button></td>
		</tr>
		<tr>
			<td><a href="rawData.html">View raw data</a></td>
			<td><a href="info.php">View PHP info</a></td>
		</tr>
	</table>
</body>
</html>
