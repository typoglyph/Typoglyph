<!DOCTYPE html>
<html>
<head>
	<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
	<meta content="utf-8" http-equiv="encoding">
	<meta content='width=device-width, initial-scale=1.0' name='viewport'>
	
	<link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Droid+Sans:700">
	<link rel="stylesheet" type="text/css" href="styles/main.css">
	
	<!-- see https://github.com/davidjbradshaw/iframe-resizer -->
	<script type="text/javascript" src="scripts/lib/iframe-resizer-v3.5.0/iframeResizer.contentWindow.min.js"></script>
	<script type="text/javascript" src="scripts/lib/interact.js-v1.2.6/interact.min.js"></script>
	<script type="text/javascript" src="scripts/common.js"></script>
	<script type="text/javascript" src="scripts/util.js"></script>
	<script type="text/javascript" src="scripts/ui.js"></script>
	<script>
	
	
	// Imports
	var util = typoglyph.util;
	var PuzzleDrawer = typoglyph.ui.PuzzleDrawer;
	var PuzzleGapDrawer = typoglyph.ui.PuzzleGapDrawer;
	var PuzzleOptionDrawer = typoglyph.ui.PuzzleOptionDrawer;
	var PuzzleOptionBarDrawer = typoglyph.ui.PuzzleOptionBarDrawer;
	
	
	// Global variables
	var _currentPuzzle = null;
	var _onPuzzleCompleteListener = null;
	
	var _puzzleDrawer = null;
	var _optionBarDrawer = null;
	
	
	// Visible to other pages (when this page is embeded inside another)
	/**
	 * Displays the given puzzle for the user to start solving
	 * 
	 * @param {Puzzle} puzzle
	 */
	function showPuzzle(puzzle) {
		_currentPuzzle = puzzle;
		renderCurrentPuzzle();
	}
	
	/**
	 * Sets up a listener which will be called when the user has completed the shown puzzle. The
	 * listener will be given two arguments: the puzzle which was completed, and a boolean
	 * indicating if it was solved correctly.
	 * 
	 * Pass null to remove the current listener.
	 * 
	 * @param {function(Puzzle, boolean)} listener
	 */
	function setOnPuzzleCompleteListener(listener) {
		_onPuzzleCompleteListener = listener;
	}
	
	
	// Event handlers
	/**
	 * Called when the browser has finished (re)loading the document
	 */
	function onLoad() {
		console.debug("onLoad");
		
		// DI would be nice here... oh well
		var optionDrawer = PuzzleOptionDrawer.create();
		var gapDrawer = PuzzleGapDrawer.create(optionDrawer, false);
		_puzzleDrawer = PuzzleDrawer.create(gapDrawer);
		_optionBarDrawer = PuzzleOptionBarDrawer.create(optionDrawer);
		
		initTouchControls();
	}
	
	/**
	 * Called whenever the size of the viewport changes
	 * 
	 * @param {Event} event
	 */
	function onResize(event) {
		console.debug("onResize: event=" + event);
	}
	
	/**
	 * Called whenever the orientation of the device changes. Note browser support is spotty - some
	 * may call onResize(), some may call onOrientationChange(), some may all both, some may not
	 * call either
	 */
	function onOrientationChange(event) {
		console.debug("onOrientationChange: event=" + event);
	}
	
	/**
	 * @param {MouseEvent} event Information about the click event
	 * @param {HTMLElement} element The DOM element which was clicked
	 */
	function onNextPuzzleButtonClicked(event, element) {
		console.debug("onNextPuzzleButtonClicked: event=" + event + ", element=" + element);
		if (_onPuzzleCompleteListener !== null)
			_onPuzzleCompleteListener(event, _currentPuzzle, _currentPuzzle.areAllGapsFilledCorrectly());
	}
	
	/**
	 * @param {MouseEvent} event Information about the click event
	 * @param {HTMLElement} element The DOM element which was clicked
	 */
	function onResetPuzzleButtonClicked(event, element) {
		console.debug("onResetPuzzleButtonClicked: event=" + event + ", element=" + element);
		
		for (var i = 0; i < _currentPuzzle.gaps.length; i++) {
			var gap = _currentPuzzle.gaps[i];
			gap.currentChoice = null;
		}
		renderCurrentPuzzle();
	}
	
	
	// Rendering functions
	/**
	 * (Re)Draw the current puzzle on the screen
	 */
	function renderCurrentPuzzle() {
		var puzzleElement = document.getElementById("puzzleSentence");
		util.removeAllChildren(puzzleElement);
		_puzzleDrawer.drawInto(puzzleElement, _currentPuzzle);
		
		var optionBarElement = document.getElementById("puzzleOptions");
		util.removeAllChildren(optionBarElement);
		_optionBarDrawer.drawInto(optionBarElement, _currentPuzzle.options);
	}
	
	
	function initTouchControls() {
		
		// Defines how puzzle options can be dragged
		interact(".puzzleOption").draggable({
			inertia: false,
			autoScroll: false,
			restrict: {
				restriction: function() { return document.body.getBoundingClientRect(); },
				elementRect: {
					left: 0,
					right: 1,
					top: 0,
					bottom: 1
				}
			},
			max: 1,
			maxPerElement: 1,
			
			/**
			 * Called periodically as event.target is being dragged around so the element's
			 * position can be updated. event.dx and event.dy describe how far the element has
			 * been dragged since the previous call to this function. Note that the given event.dx
			 * and event.dy will never take event.target outside the defined restriction area.
			 * 
			 * @param {Event} event
			 */
			onmove: function(event) {
				console.debug("onmove: target=" + event.target.id);
				
				var dragDistanceX = parseFloat(event.target.getAttribute("data-dragDistanceX")) || 0;
				var dragDistanceY = parseFloat(event.target.getAttribute("data-dragDistanceY")) || 0;
				event.target.setAttribute("data-dragDistanceX", dragDistanceX += event.dx);
				event.target.setAttribute("data-dragDistanceY", dragDistanceY += event.dy);
				
				util.setElementTranslation(event.target, dragDistanceX, dragDistanceY);
			},
			/**
			 * Called when event.target has just started being dragged, just before the first call
			 * to onmove().
			 * 
			 * Note: This function is called before ondropactivate() if a drop zone has been set to
			 * accept event.target.
			 * 
			 * @param {Event} event
			 */
			onstart: function(event) {
				console.debug("onstart: target=" + event.target.id);
				util.addClass(event.target, "highlight");
			},
			/**
			 * Called when event.target has just stopped being dragged, just after the last call to
			 * onmove().
			 * 
			 * Note: This function is called after ondropdeactivate() if a drop zone has been set
			 * to accept event.target.
			 * 
			 * @param {Event} event
			 */
			onend: function(event) {
				console.debug("onend: target=" + event.target.id);
				util.removeClass(event.target, "highlight");
			}
		});
		
		// Defines how puzzle gaps (and options which are inside gaps) can be dropzones
		// Potentially inefficient: Actually makes every element on the page a dropzone
		interact("*").dropzone({
			accept: ".puzzleOption", // Only allow puzzle options to be dropped here
			overlap: 0.1,
			
			/**
			 * Called just after event.relatedTarget has been dropped anywhere inside event.target
			 * (the dropzone)
			 * 
			 * @param {Event} event
			 */
			ondrop: function(event) {
				console.debug("ondrop: target=" + event.relatedTarget.id + ", origin=" + event.relatedTarget.parentNode.id + ", dest=" + event.target.id);
				
				if (util.getClasses(event.relatedTarget).contains("puzzleOption")) {
					// A puzzle option is being dropped somewhere
					var optionId = parseInt(event.relatedTarget.getAttribute("data-id"));
					var option = _currentPuzzle.getOptionById(optionId);
					
					if (util.getClasses(event.relatedTarget.parentNode).contains("puzzleGap")) {
						// A puzzle option is being dragged from a puzzle gap
						var originGapId = parseInt(event.relatedTarget.parentNode.getAttribute("data-id"));
						_currentPuzzle.getGapById(originGapId).currentChoice = null;
					}
					
					if (util.getClasses(event.target).contains("puzzleGap")) {
						// A puzzle option is being dropped into a puzzle gap
						var destinationGapId = parseInt(event.target.getAttribute("data-id"));
						_currentPuzzle.getGapById(destinationGapId).currentChoice = option;
						
					} else if (util.getClasses(event.target).contains("puzzleOption")
							&& util.getClasses(event.target.parentNode).contains("puzzleGap")) {
						// A puzzle option is being dropped into an already-populated gap
						var destinationGapId = parseInt(event.target.parentNode.getAttribute("data-id"));
						_currentPuzzle.getGapById(destinationGapId).currentChoice = option;
					}
				}
			},
			/**
			 * Called when event.relatedTarget has been picked up and has just started being
			 * dragged
			 *
			 * @param {Event} event
			 */
			ondropactivate: function(event) {
				console.debug("ondropactivate: target=" + event.relatedTarget.id + ", origin=" + event.relatedTarget.parentNode.id + ", dest=" + event.target.id);
			},
			/**
			 * Called when event.relatedTarget has been dropped. If event.relatedTarget is inside
			 * the dropzone, this function will be called just *after* ondrop() (but will still be
			 * called even if it's outside the drop zone).
			 * 
			 * @param {Event} event
			 */
			ondropdeactivate: function(event) {
				var originId = (event.relatedTarget.parentNode === null) ? null : event.relatedTarget.parentNode.id;
				console.debug("ondropdeactivate: target=" + event.relatedTarget.id + ", origin=" + originId + ", dest=" + event.target.id);
				renderCurrentPuzzle();
			}
		});
	}
	</script>
</head>
<body onload="onLoad();" onresize="onResize(event);" onorientationchange="onOrientationChange(event);">
	<div id="puzzleOptions"></div>
	<div id="puzzleSentence"></div>
	<div class="buttonHolder">
		<img id="resetPuzzle" class="button" src="images/button_reset.svg" onclick="onResetPuzzleButtonClicked(event, this);" />
		<img id="nextPuzzle" class="button" src="images/button_next.svg" onclick="onNextPuzzleButtonClicked(event, this);" />
	</div>
</body>
</html>
