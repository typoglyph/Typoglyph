<!DOCTYPE html>
<html>
<head>
	<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
	<meta content="utf-8" http-equiv="encoding">
	
	<link rel="stylesheet" type="text/css" href="styles/common.css">
	<link rel="stylesheet" type="text/css" href="styles/index.css">
	
	<script type="text/javascript" src="http://code.interactjs.io/v1.2.6/interact.js"></script>
	<script type="text/javascript" src="scripts/common.js"></script>
	<script type="text/javascript" src="scripts/util.js"></script>
	<script type="text/javascript" src="scripts/ui.js"></script>
	<script>
	
	
	// Imports
	var util = typoglyph.util;
	var PuzzleDrawer = typoglyph.ui.PuzzleDrawer;
	var PuzzleGapDrawer = typoglyph.ui.PuzzleGapDrawer;
	var PuzzleOptionDrawer = typoglyph.ui.PuzzleOptionDrawer;
	var PuzzleOptionBarDrawer = typoglyph.ui.PuzzleOptionBarDrawer;
	
	
	// Global variables
	var _currentPuzzle = null;
	var _onPuzzleCompleteListener = null;
	
	var _puzzleDrawer = null;
	var _optionBarDrawer = null;
	
	
	// Visible to other pages (when this page is embeded inside another)
	/**
	 * Displays the given puzzle for the user to start solving
	 * 
	 * @param {Puzzle} puzzle
	 */
	function showPuzzle(puzzle) {
		_currentPuzzle = puzzle;
		renderCurrentPuzzle();
	}
	
	/**
	 * Sets up a listener which will be called when the user has completed the shown puzzle. The
	 * listener will be given two arguments: the puzzle which was completed, and a boolean
	 * indicating if it was solved correctly.
	 * 
	 * Pass null to remove the current listener.
	 * 
	 * @param {function(Puzzle, boolean)} listener
	 */
	function setOnPuzzleCompleteListener(listener) {
		_onPuzzleCompleteListener = listener;
	}
	
	
	// Event handlers
	/**
	 * Called when the browser has finished (re)loading the document
	 */
	function onLoad() {
		console.log("onLoad");
		
		// DI would be nice here... oh well
		var optionDrawer = PuzzleOptionDrawer.create();
		var gapDrawer = PuzzleGapDrawer.create(optionDrawer, false);
		_puzzleDrawer = PuzzleDrawer.create(gapDrawer);
		_optionBarDrawer = PuzzleOptionBarDrawer.create(optionDrawer);
		
		initTouchControls();
	}
	
	/**
	 * @param {MouseEvent} event Information about the click event
	 * @param {HTMLElement} element The DOM element representing the button which was clicked
	 */
	function onNextPuzzleButtonClicked(event, element) {
		console.log("onNextPuzzleButtonClicked: event=" + event + ", element=" + element);
		if (_onPuzzleCompleteListener !== null)
			_onPuzzleCompleteListener(event, _currentPuzzle, _currentPuzzle.areAllGapsFilledCorrectly());
	}
	
	
	// Rendering functions
	/**
	 * (Re)Draw the current puzzle on the screen
	 */
	function renderCurrentPuzzle() {
		var puzzleElement = document.getElementById("puzzleSentence");
		var optionBarElement = document.getElementById("puzzleOptions");
		
		var drawnPuzzle = _puzzleDrawer.draw(_currentPuzzle);
		var drawnOptions = _optionBarDrawer.draw(_currentPuzzle.options);
		util.removeAllChildren(puzzleElement);
		util.removeAllChildren(optionBarElement);
		puzzleElement.appendChild(drawnPuzzle);
		optionBarElement.appendChild(drawnOptions);
	}
	
	
	function initTouchControls() {
		interact(".puzzleOption").draggable({
			inertia: false,
			autoScroll: false,
			restrict: {
				restriction: document.body.getBoundingClientRect(),
				elementRect: {
					left: 0,
					right: 1,
					top: 0,
					bottom: 1
				}
			},
			max: 1,
			maxPerElement: 1,
			onmove: function(event) {
				var target = event.target;
				//console.log("[" + target.className + "].onmove: dx=" + event.dx + ", dy=" + event.dy);
				var x = (parseFloat(target.getAttribute("data-x")) || 0) + event.dx;
				var y = (parseFloat(target.getAttribute("data-y")) || 0) + event.dy;
				
				
				// translate the element
				target.style.transform = target.style.webkitTransform = "translate(" + x + "px, " + y + "px)";
				
				// update the position attributes
				target.setAttribute("data-x", x);
				target.setAttribute("data-y", y);
			},
			/*onend: function(event) {
				var target = event.target;
				console.log("[" + target.className + "].ondrop");
				target.setAttribute("data-x", null);
				target.setAttribute("data-y", null);
				target.style.transform = target.style.webkitTransform = "";
			}*/
		});
		
		interact(".puzzleGap").dropzone({
			accept: ".puzzleOption",
			overlap: 0.1,
			ondrop: function(event) {
				// event.relatedTarget was just dropped in the dropzone
				console.log("onDrop: target=" + event.target.className + ", related=" + event.relatedTarget.className);
				
				var optionId = parseInt(event.relatedTarget.getAttribute("data-id"));
				var gapId = parseInt(event.target.getAttribute("data-id"));
				var option = _currentPuzzle.getOptionById(optionId);
				var gap = _currentPuzzle.getGapById(gapId);
				
				gap.currentChoice = option;
			},
			ondropactivate: function(event) {
				// event.relatedTarget was just picked up
				console.log("onDropActivate: target=" + event.target.className + ", related=" + event.relatedTarget.className);
			},
			ondropdeactivate: function(event) {
				// event.relatedTarget was just dropped (possibly in the dropzone, but maybe not)
				// called just after ondrop
				console.log("onDropDeactivate: target=" + event.target.className + ", related=" + event.relatedTarget.className);
				renderCurrentPuzzle();
			}
		});
	}
	</script>
</head>
<body onload="onLoad();">
	<table>
		<tr>
			<td>Options:</td>
			<td id="puzzleOptions"></td>
		</tr>
		<tr>
			<td>Sentence:</td>
			<td id="puzzleSentence"></td>
		</tr>
		<tr>
			<td><button id="nextPuzzle" class="button" onclick="onNextPuzzleButtonClicked(event, this);">Check answer | Next puzzle</button></td>
		</tr>
	</table>
</body>
</html>
